\documentclass {article}

\usepackage{amsfonts} % pour les lettres maths creuses \mathbb
\usepackage{amsmath}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage{aeguill}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{color}
\usepackage{listings}

\newcommand\dx{\dot{x}}
\newcommand\dy{\dot{y}}
\newcommand\ddx{\ddot{x}}
\newcommand\ddy{\ddot{y}}
\def\real{{\mathbb R}}

\author {Steve Tonneau et Florent Lamiraux\\
CNRS-LAAS, Toulouse, France}
\title {Travaux pratiques sous HPP}
\date {}

\begin {document}
\maketitle

\section* {Introduction}
L'objectif de ce TP est d'impl\'ementer
un algorithme de planification de mouvement en utilisant
le framework HPP (Humanoid Path Planner).
HPP regroupe un ensemble d'algorithmes utilis\'es de mani\`ere classique pour des robots complexes,
tel que l'humano\"ide HRP-2. Il propose aussi un outil, le gepetto-viewer, 
utilis\'e pour visualiser les trajectoires calcul\'ees pour le robot.
Gr\^ace \`a une interface en python, l'outil est assez facile d'utilisation.

Dans une premi\`ere (courte) partie du TP, vous allez utiliser l'interface python en tant qu'utilisateur
pour r\'esoudre un probl\`eme de planification pour le robot PR-2.

Dans une deuxi\`eme partie, vous allez devoir impl\'ementer, puis tester, votre propre algorithme de planification
de mouvement en utilisant les interfaces de HPP.

\section {Mise en place}
HPP et les tutorials sont install\'es dans une machine virtuelle, sur laquelle vous allez devoir travailler.
La machine virtuelle \'emule un syst\`eme d'exploitation Ubuntu 14.04, sur lequel est install\'e HPP.

Vous allez travailler sur un dossier partag\'e entre votre machine physique et la machine virtuelle,
pour plus de s\'ecurit\'e.

Pour ce faire, cr\'eez un dossier local sur votre machine portant votre nom:
\begin{lstlisting}[language=bash]
  $ mkdir ~/tp_hpp_xxx_share
\end{lstlisting}
% $

Ensuite, lancez la machine virtuelle.
Ouvrez un terminal et tapez la commande:
\begin{lstlisting}[language=bash]
  $ virtualbox
\end{lstlisting}
% $


Dans l'interface virtualbox s\'electionnez la machine virtuelle u1404x32\_1 et cliquez sur "configuration", puis sur "shared folders".
Ajouter le dossier cr\'ee, et cochez la case "automount".


Ensuite, lancer la machine virtuelle u1404x32\_1 en la s\'electionnant puis en cliquant sur "Start".

Une fois la machine lanc\'ee, ouvrez y un terminal et montez votre dossier dans le r\'epertoire $home/student/dev/hpp/src$

\begin{lstlisting}[language=bash]
  $ cd ~/dev/hpp/src
  $ cd mkdir tp_hpp_xxx
  $ sudo mount -t vboxsf tp_hpp_xxx_share ~/dev/hpp/src/tp_hpp_xxx 
\end{lstlisting}
%$
le mot de passe du compte student est student.

\section {Prise en main de l'interface python HPP}
\subsection{Tutorial 1 HPP}
Dans un navigateur, ouvrez la page ~/dev/hpp/install/share/doc/hpp-doc/index.html et lisez la pr\'esentation du logiciel.
Ensuite, cliquez \`a gauche de la page sur "Tutorial", puis "Tutorial 1".
Suivez les instructions du tutorial.
Le mouvement final peut se jouer de mani\`ere assez lente en raison de la machine virtuelle.

\subsection{D\'efinition d'un nouveau probl\`eme en python}
A partir du script du tutoriel 1, nous allons d\'efinir un nouveau probl\`eme.
Pour cela il faut d'abord r\'ecup\'erer les donn\'ees du nouveau tp.
\begin{lstlisting}[language=bash]
  $ cd ~/dev/hpp/src/tp_hpp_xxx
  $ git clone --recursive https://github.com/laastp/hpp_aip.git
\end{lstlisting}
%$
Ensuite, compiler le projet avec cmake
\begin{lstlisting}[language=bash]
  $ cd ~/dev/hpp/src/tp_hpp_xxx/build
  $ cmake ..
  $ make
\end{lstlisting}
%$

A ce stade, appeler l'encadrant pour modifier la variable d'installation
du paquet.
Une fois compil\'e et install\'e, un nouveau serveur est disponible dans la console:
hpp-tp-rrt. Dans tout le reste du tp, on lancera ce serveur \`a la place de hppcorbaserver
pour tester les r\'eponses aux questions.

\subsection{D\'efinition d'un nouveau probl\`eme en python}
\paragraph {Question 1:}
En s'inspirant du tutoriel 1, compl\'eter le script situ\'e dans tp\_hpp\_xxx/script pour 
charger le robot "buggy" et la scene "scene".
Le robot buggy est un robot qui peut se d\'eplacer en 2 dimensions, et poss\`ede en plus un angle
d'orientation, donn\'e par son cosinus et son sinus. On ne consid\`ere pas les autres degr\'es de
libert\'e pour l'instant.

D\'efinir une position de d\'epart en [-3.7, -4] et la position d'arriv\'ee en [15,2],
calculer et jouer la solution.

\subsection{Impl\'ementation d'un nouveau plannificateur de mouvement en c++}
Dans la suite du TP, nous allons maintenant utiliser l'API HPP pour d\'efinir un nouveau planificateur de mouvement.
Vous allez impl\'ementer l'algorithme RRT vu en cours.
Tout au long de l'impl\'ementation, les classes \`a utiliser vous sont donn\'ees.
C'est \`a vous d'utiliser la documentation HPP pour parcourir les m\'ethodes et appeler celles qui vous int\'eressent.
Un squelette vous est fourni, qu'il vous faut remplir.

\paragraph{Environnement de programmation}
Bien que cela ne soit pas obligatoire, il est conseill\'e d'utiliser l'IDE QTcreator pour travailler sur ce tp.
QTcreator se lance avec la commande 
\begin{lstlisting}[language=bash]
  $ qtcreator&
\end{lstlisting}
%$

Pour ouvrir le projet, choisissez File...Open file or Project, et choisissez le fichier "CMakeLists.txt"
qui se trouve \`a la racine. Dans l'invite qui appara\^it, choisissez le r\'epertoire build cr\'ee pr\'ec\'edemment et non
pas le r\'epertoire par d\'efaut. La touche F4 permet de naviguer entre .hh et .cc, et la touche F2 vous 
permet de vous rendre \`a l'endroit o\`u est d\'efinie une variable ou un type sous le curseur de la souris.

\paragraph {Question 3:}
Commencez par impl\'ementer la m\'ethode $shoot$ de la classe ShooterTp (shooter-tp.cc).
Il s'agit d'\'echantilloner uniform\'ement chaque articulation (joint) du robot.

\paragraph {Question 4:}
Impl\'ementer la m\'ethode $oneStep$ de la classe PlannerTp (planner-tp.cc).
$oneStep$ correspond \`a une it\'eration de l'algorithme RRT, c'est \`a dire \`a l'\'echantillonage d'une configuration,
et, si possible, \`a sa connexion avec des \'el\'ements de la roadmap.
$oneStep$ appelle la m\'ethode $extend$ que vous devez \'egalement impl\'ementer.
Attention, dans HPP, chaque noeud cr\'e\'e est associ\'e automatiquement \'a une composante connexe.
Lorsque des noeuds de composantes connexes diff\'erentes sont connect'es, ces composantes connexes sont automatiquement
fusionn\'ees.

Pour v\'erifier qu'un chemin est (partiellement) valide, vous pouvez utiliser directement la classe
"PathValidation".

\paragraph {Question 5:}
Tester votre planner. Pour cela modifier le script que vous avez choisi pour lancer votre planner.
Le nom du planner que vous avez d\'efini est renseign\'e dans le fichier main.cc.

\paragraph {Question 6:}
Tester l'algorithme d'optimisation $RandomShortcut$ avec votre planner, et v\'erifier qu'il fonctionne.

\paragraph {Question 7:}
Biaiser la m\'ethode d'\'echantillonnage pour qu'une fois sur dix, elle retourne la configuration d'arriv\'ee.
Cela a t'il une influence sur le temps de calcul? Le chemin trouv\'e?
Pourquoi?

\paragraph{Question 8:}
Impl\'ementer votre propre m\'ethode de validation de chemin, en utilisant une m\'ethode it\'erative
vue en cours. Pour simplifier le travail, une free function $validate$ a été d\'efinie dans planner-tp.cc.
Il vous faut la compl\'eter, puis modifier votre planner pour appeler cette m\'ethode.

\paragraph{Question 9:}
Modifier votre planner pour impl\'ementer cette fois l'algorithme PRM.
Quelles sont les diff\'erences entre les deux algorithmes?


\end {document}
